// Generated by CoffeeScript 1.10.0
(function() {
  var ManyFuture, OnceFuture, future,
    slice = [].slice;

  OnceFuture = (function() {
    function OnceFuture(ms, cb1) {
      this.ms = ms;
      this.cb = cb1;
      this.runTime = (function(_this) {
        return function() {
          _this.res = _this.cb();
          return _this.timer = null;
        };
      })(this);
      this.timer = setTimeout(this.runTime, this.ms);
    }

    OnceFuture.prototype.cancel = function() {
      if (this.isDone()) {
        return false;
      }
      clearTimeout(this.timer);
      this.timer = void 0;
      return true;
    };

    OnceFuture.prototype.finish = function() {
      var params;
      params = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (this.isDone()) {
        return false;
      }
      clearTimeout(this.timer);
      this.res = this.cb.apply(this, params);
      this.timer = null;
      return true;
    };

    OnceFuture.prototype.result = function() {
      return this.res;
    };

    OnceFuture.prototype.isDone = function() {
      return this.timer === void 0 || this.timer === null;
    };

    OnceFuture.prototype.isCancelled = function() {
      return this.timer === void 0;
    };

    return OnceFuture;

  })();

  ManyFuture = (function() {
    function ManyFuture(ms, maxRun, cb1) {
      this.ms = ms;
      this.maxRun = maxRun;
      this.cb = cb1;
      this.n = 0;
      this.runTime = (function(_this) {
        return function() {
          _this.res = _this.cb();
          _this.n++;
          if (_this.n === _this.maxRun) {
            if (_this.finishCb) {
              _this.finishCb();
            }
            if (_this.n === _this.maxRun) {
              clearInterval(_this.timer);
              return _this.timer = null;
            }
          }
        };
      })(this);
      this.timer = setInterval(this.runTime, this.ms);
    }

    ManyFuture.prototype._remainTimes = function() {
      return this.maxRun - this.n;
    };

    ManyFuture.prototype.cancel = function() {
      if (this.isDone()) {
        return false;
      }
      clearInterval(this.timer);
      this.timer = void 0;
      return true;
    };

    ManyFuture.prototype.finish = function() {
      var params;
      params = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (this.isDone()) {
        return false;
      }
      clearInterval(this.timer);
      this.res = this.cb.apply(this, params);
      this.n++;
      this.timer = null;
      return true;
    };

    ManyFuture.prototype.finishAfter = function(n, finishCb) {
      this.finishCb = finishCb;
      return this.maxRun = this.n + n;
    };

    ManyFuture.prototype.result = function() {
      return this.res;
    };

    ManyFuture.prototype.isDone = function() {
      return this.timer === void 0 || this.timer === null;
    };

    ManyFuture.prototype.isCancelled = function() {
      return this.timer === void 0;
    };

    ManyFuture.prototype.resetInterval = function(ms) {
      this.ms = ms;
      if (this.timer) {
        clearInterval(this.timer);
        return this.timer = setInterval(this.runTime, this.ms);
      }
    };

    return ManyFuture;

  })();

  future = {
    once: function(msInFuture, runCb) {
      return new OnceFuture(msInFuture, runCb);
    },
    interval: function(msInterval, runCb) {
      return new ManyFuture(msInterval, -1, runCb);
    },
    timeoutWrap: function(msTimeout, fn, ctx) {
      if (ctx) {
        fn = fn.bind(ctx);
      }
      return (function(_this) {
        return function() {
          var called, cb, fargs, j, task;
          fargs = 2 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 1) : (j = 0, []), cb = arguments[j++];
          called = false;
          task = future.once(msTimeout, function() {
            if (!called) {
              called = true;
              return cb(new Error("Timed out after " + msTimeout + " ms"));
            }
          });
          return fn.apply(null, slice.call(fargs).concat([function() {
            var cbargs;
            cbargs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            if (!called) {
              task.cancel();
              called = true;
              return cb.apply(null, cbargs);
            }
          }]));
        };
      })(this);
    },
    loop: function(msPause, runCb) {
      var doloop, i;
      i = 0;
      doloop = (function(_this) {
        return function() {
          return future.once(msPause, function() {
            return runCb(i++, doloop);
          });
        };
      })(this);
      return doloop();
    }
  };

  module.exports = future;

}).call(this);

//# sourceMappingURL=future.js.map
